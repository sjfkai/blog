<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="sjfkai,sjfkai@gmail.com"><title>简易数据结构 · Just Blog</title><meta name="description" content="简易数据结构今天我们将要了解并学习数据结构。
&amp;quot;OOooooOOOooh *soo* exciting&amp;quot; right?
没错，它不是最有内容的话题，但它很重要。并非为了向计算机输入奇怪的101，而是让自己成为一名更好的程序员。
理解数据结构可以让你：

管理复杂的系统，并使你的代"><meta name="keywords" content="blog,Just Blog,sjfkai,前端,大前端,程序员"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-110880274-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-110880274-1');</script></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Just Blog</a></h3></div></div><ul class="social-links"><li><a href="http://github.com/sjfkai"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div><script>var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1267679219'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1267679219%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>简易数据结构</a></h3></div><div class="post-content"><h1 id="简易数据结构"><a href="#简易数据结构" class="headerlink" title="简易数据结构"></a>简易数据结构</h1><p>今天我们将要了解并学习数据结构。</p>
<pre><code>&quot;OOooooOOOooh *soo* exciting&quot; right?
</code></pre><p>没错，它不是最有内容的话题，但它很重要。并非为了向计算机输入奇怪的101，而是让自己成为一名<br>更好的程序员。</p>
<p>理解数据结构可以让你：</p>
<ul>
<li>管理复杂的系统，并使你的代码更易维护。</li>
<li>构建高性能，高效率的应用。</li>
</ul>
<p>我认为前者更重要一些。使用正确的数据结构可以大幅简化本来很复杂的逻辑。</p>
<p>当然后者同样重要。如果关心性能和内存，应用正确的数据机构比通常的解决方案更重要。</p>
<p>为了了解数据结构，我们准备尝试一起实现它们中的一部分。别怕，我们将保持代码的简洁。<br>实际上，注释要比代码多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ============================================================================</span><br><span class="line"> * ,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;</span><br><span class="line"> * ============================================================================</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p> 实际上，他们是一些不同的存储和组织数据的方法，供若干不同的需求使用。</p>
<p> 数据总可以以很多不同的方式表现。然而，基于数据的具体内容与它的用途，总有一种表现方式更优一些。</p>
<p> 想要理解为什么，让我们先简单聊一聊算法。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - 算法 ---------------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                                                                           *</span><br><span class="line"> *                        ,--,--.    ,--,--.                                 *</span><br><span class="line"> *   ,----------.        |   |   |  |   |   |            _____               *</span><br><span class="line"> *  |`----------&apos;|       |   |   |  |   |   |           |     |    ,------.  *</span><br><span class="line"> *  |            |       |   |   |  |   |   |      ,--. | o o |   |`------&apos;| *</span><br><span class="line"> *  |            |      ,| +-|-+ |  | +-|-+ |`     |  | |_____|   |        | *</span><br><span class="line"> *  |            | ,:==| | |###|======|###| | |====#==#====#=,,   |        | *</span><br><span class="line"> *  |            | ||   `| +---+ |  | +---+ |&apos;  ,,=#==#====O=``  ,|        | *</span><br><span class="line"> *  |            | ||    |   |   |  |   |   |   ``=#==#====#=====||        | *</span><br><span class="line"> *   `----------&apos;  ||    |   |   |  |   |   |      |__|          `|        | *</span><br><span class="line"> *    | | ``=| |===``    `--,&apos;,--`  `--,&apos;,--`      /||\            `------&apos;  *</span><br><span class="line"> **   \_/    \_/         / /   \ \  / /   \ \     //||\\           |_|  |_| **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 算法，是一系列操作被一步步执行的美称。</p>
<p> 数据结构由算法实现，而算法又基于数据结构。数据结构与算法一直往下，直到你看见一群使用打<br> 孔卡操作计算机的小人儿。（额- Intel奴役这这群小人儿。 醒醒别睡了！！）</p>
<p> 任何任务都可以有无数的实现方法。所以对于相同的任务，人们会想出很多不同的算法。</p>
<p> 比如，有非常庞大的数量的算法可以用来给乱序的事物排序：</p>
<pre><code>Insertion Sort(插入排序), Selection Sort(选择排序), Merge Sort(归并排序),
Bubble Sort(冒泡排序), Heap Sort(堆排序), Quick Sort(快速排序), 
Shell Sort(希尔排序), Timsort, Bucket Sort(桶排序), Radix Sort(基数排序), ...
</code></pre><p> 它们之间有一些明显比其他的速度快。有一些使用更少的内存。有一些更容易实现。<br> 有一些基于数据集的某些前提。</p>
<p> 任何一个都比其他的在 <em>某方面</em> 有优势。所以你需要根据你的需求做选择，因此你需要一个考量和<br> 比较算法的方法。</p>
<p> 我们使用对算法的平均与最差性能进行粗略测量，来比较算法的性能。它被称为”大O”。</p>
<h2 id="大O-符号"><a href="#大O-符号" class="headerlink" title="大O 符号"></a>大O 符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - 大O 符号 ------------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *           a           b                                 d                 *</span><br><span class="line"> *           a         b    O(N^2)                      d                    *</span><br><span class="line"> *     O(N!) a        b                O(N log N)    d                    c  *</span><br><span class="line"> *           a      b                            d                 c         *</span><br><span class="line"> *          a      b                          d             c        O(N)    *</span><br><span class="line"> *          a    b                         d         c                       *</span><br><span class="line"> *          a  b                       d      c                              *</span><br><span class="line"> *         a  b                     d  c                                     *</span><br><span class="line"> *         ab                   c                          O(1)              *</span><br><span class="line"> *  e    e    e    e    ec   d    e    e    e    e    e     e    e    e      *</span><br><span class="line"> *      ba        c      d                                                   *</span><br><span class="line"> *    ba   c        d                       f    f    f    f    f    f    f  *</span><br><span class="line"> ** cadf    f d    f    f    f    f    f       O(log N)                     **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p>大O 符号是粗略测量算法性能的一种方法，以至于可以在讨论的时候对两个算法进行比较。</p>
<p>大O 是计算机科学中借来的一个数学符号。根据算法对给予它元素的数目(N)而表现结果，将算法分类。</p>
<p>你主要可以用大O测量两个东西：</p>
<ul>
<li><p><strong>时间复杂度</strong> 表示对于给予一系列元素(N)，算法需要操作的总次数。</p>
</li>
<li><p><strong>空间复杂度</strong> 表示对于给予一系列元素(N)，算法运行所需要的总内存。</p>
</li>
</ul>
<p>我们在在对比其中一项指标是一定要独立于另一个。因为一个算法可能比另一个需要的操作次数少。<br>它通常需要更多的内存。依照你的需求，选出更好的那一个。</p>
<p>这是一些常见的 大O:</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">符号</th>
<th style="text-align:left">当用到它时你的感觉</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">常数</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">爽!!</td>
</tr>
<tr>
<td style="text-align:left">对数</td>
<td style="text-align:left">O(log N)</td>
<td style="text-align:left">不错哦!</td>
</tr>
<tr>
<td style="text-align:left">线性</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">还行.</td>
</tr>
<tr>
<td style="text-align:left">对数线性</td>
<td style="text-align:left">O(N log N)</td>
<td style="text-align:left">额…</td>
</tr>
<tr>
<td style="text-align:left">平方</td>
<td style="text-align:left">O(N ^ 2)</td>
<td style="text-align:left">不好</td>
</tr>
<tr>
<td style="text-align:left">指数</td>
<td style="text-align:left">O(2 ^ N)</td>
<td style="text-align:left">可怕</td>
</tr>
<tr>
<td style="text-align:left">阶乘</td>
<td style="text-align:left">O(N!)</td>
<td style="text-align:left">艹！</td>
</tr>
</tbody>
</table>
<p>为了给大家一个具体的印象，具体的需要进行多少次操作。我们看一下具体元素数(N)对应的操作数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">N</th>
<th style="text-align:left">5</th>
<th style="text-align:left">10</th>
<th style="text-align:left">20</th>
<th style="text-align:left">30</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">O(log N)</td>
<td style="text-align:left">1.6094…</td>
<td style="text-align:left">2.3025…</td>
<td style="text-align:left">2.9957…</td>
<td style="text-align:left">3.4011…</td>
</tr>
<tr>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">5</td>
<td style="text-align:left">10</td>
<td style="text-align:left">20</td>
<td style="text-align:left">30</td>
</tr>
<tr>
<td style="text-align:left">O(N log N)</td>
<td style="text-align:left">8.0471…</td>
<td style="text-align:left">23.0258…</td>
<td style="text-align:left">59.9146…</td>
<td style="text-align:left">102.0359…</td>
</tr>
<tr>
<td style="text-align:left">O(N ^ 2)</td>
<td style="text-align:left">25</td>
<td style="text-align:left">100</td>
<td style="text-align:left">400</td>
<td style="text-align:left">900</td>
</tr>
<tr>
<td style="text-align:left">O(2 ^ N)</td>
<td style="text-align:left">32</td>
<td style="text-align:left">1024</td>
<td style="text-align:left">1,048,576</td>
<td style="text-align:left">1,073,741,824</td>
</tr>
<tr>
<td style="text-align:left">O(N!)</td>
<td style="text-align:left">120</td>
<td style="text-align:left">3,628,800</td>
<td style="text-align:left">2,432,902,0…</td>
<td style="text-align:left">265,252,859,812,191,058,636,308,480,000,000</td>
</tr>
</tbody>
</table>
<p>正如你看到的，即使对于较小的数据集你也可能做<em>很多</em>额外的工作。</p>
<p>通过数据结构，你可以进行四种主要的操作：<br>访问，查询，插入，和删除。</p>
<p>需要提醒的是，数据结构可能在某方面表现不错，但在另一方面表现很差。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Accessing</th>
<th style="text-align:left">Searching</th>
<th style="text-align:left">Inserting</th>
<th style="text-align:left">Deleting</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(N)</td>
</tr>
<tr>
<td style="text-align:left">链表</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">二叉搜索树</td>
<td style="text-align:left">O(log N)</td>
<td style="text-align:left">O(log N)</td>
<td style="text-align:left">O(log N)</td>
<td style="text-align:left">O(log N)</td>
</tr>
</tbody>
</table>
<p>  或者…</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Accessing</th>
<th style="text-align:left">Searching</th>
<th style="text-align:left">Inserting</th>
<th style="text-align:left">Deleting</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数组</td>
<td style="text-align:left">爽!!</td>
<td style="text-align:left">还行!</td>
<td style="text-align:left">还行!</td>
<td style="text-align:left">还行!</td>
</tr>
<tr>
<td style="text-align:left">链表</td>
<td style="text-align:left">还行!</td>
<td style="text-align:left">还行!</td>
<td style="text-align:left">爽!!</td>
<td style="text-align:left">爽!!</td>
</tr>
<tr>
<td style="text-align:left">二叉搜索树</td>
<td style="text-align:left">不错哦!</td>
<td style="text-align:left">不错哦!</td>
<td style="text-align:left">不错哦!</td>
<td style="text-align:left">不错哦!</td>
</tr>
</tbody>
</table>
<p>设置，一些操作可能会有不同的”平均”性能和”最差”性能。</p>
<p>没有最完美的数据结构，你选择某个数据结构应基于你正在做的东西，和你将要做的事情。<br>这也是为什么了解一系列不同的常见数据结构很重要。你可以从中选择你需要的。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - 内存 -------------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                             _.-..                                         *</span><br><span class="line"> *                           ,&apos;9 )\)`-.,.--.                                 *</span><br><span class="line"> *                           `-.|           `.                               *</span><br><span class="line"> *                              \,      ,    \)                              *</span><br><span class="line"> *                               `.  )._\   (\                               *</span><br><span class="line"> *                                |//   `-,//                                *</span><br><span class="line"> *                                ]||    //&quot;                                 *</span><br><span class="line"> **                        hjw    &quot;&quot;    &quot;&quot;                                  **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p>  计算机的内存很无聊，它只是一堆可以存放信息的有序的插槽。根据内存地址就可以找到信息。</p>
<p>  让我们把一块内存想象成这个样子：</p>
<pre><code>  值： |1001|0110|1000|0100|0101|1010|0010|0001|1101|1011...
地址： 0    1    2    3    4    5    6    7    8    9    ...
</code></pre><p>  如果你曾经有过为什么在编程语言里索引是以0开始的疑问，就是因为内存工作方式的原因。<br>  如果你想读取内存第一块，你需要从0读到1，第二块需要从1读到2。所以你取得的地址分别为0和1。</p>
<p>  你的计算机有比这多很多的内存，而且只是上面模式的延续。</p>
<p>  内存和狂野的西部有些相像，运行在你电脑上的每个程序都将数据保存在相同的<em>物理的</em>数据结构里。<br>  如果不将它一层层的抽象，它将极其难用。</p>
<p>  但是这些抽象服务于两个额外的目的：</p>
<ul>
<li>将数据存在内存中，使得调用时更高效、更快速。</li>
<li>将数据存在内存中，使得更易用。</li>
</ul>
<h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - LIST ------------------------------------------------------------ **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                  *     _______________________                            *</span><br><span class="line"> *                    ()=(_______________________)=()           *            *</span><br><span class="line"> *       *                |                     |                            *</span><br><span class="line"> *                        |   ~ ~~~~~~~~~~~~~   |       *               *    *</span><br><span class="line"> *             *          |                     |                            *</span><br><span class="line"> *   *                    |   ~ ~~~~~~~~~~~~~   |         *                  *</span><br><span class="line"> *                        |                     |                            *</span><br><span class="line"> *                        |   ~ ~~~~~~~~~~~~~   |                 *          *</span><br><span class="line"> *        *               |                     |                            *</span><br><span class="line"> *                   *    |_____________________|         *        *         *</span><br><span class="line"> *                    ()=(_______________________)=()                        *</span><br><span class="line"> **                                                                         **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p>  为了演示内存和数据结构之间的相互作用。我们首先准备实现一个LIST。</p>
<p>  LIST表示一个有序序列，它的值允许重复。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们先用JavaScript的数组代表一块空内存，并且我们需要保存LIST的长度。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 提示，我们另外保存长度(length),是因为真正的"内存"并没有可读取的长度(length)的地方。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = [];</span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 首先，我们需要从LIST中取得数据的方法。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 对于普通的LIST，你可以非常快的访问内存，因为你可以根据地址直接访问。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * LIST的访问为常量复杂度 O(1) - "爽!!"</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  get(address) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.memory[address];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由于LIST有一个功能，你可以在开头，中间或者结尾插入东西。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 在我们的实现中，我们准备实现如下方法，使得可以在LIST的开头或结尾添加删除内容：</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   - Push    - 在结尾增加值</span></span><br><span class="line"><span class="comment">   *   - Pop     - 删除结尾的值</span></span><br><span class="line"><span class="comment">   *   - Unshift - 在开头增加值</span></span><br><span class="line"><span class="comment">   *   - Shift   - 删除开头的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 由push开始，我们需要在LIST的结尾增加一个值。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 其实很简单，就是在LIST的结尾后面增加一个值，因为我们保存了length，所以很好计算。</span></span><br><span class="line"><span class="comment">   * 我们只需要增加一个值然后将长度加一。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 在LIST的结尾增加值为常数复杂度 O(1) - "爽!!"</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  push(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory[<span class="keyword">this</span>.length] = value;</span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接下来，我们需要在标的结尾"pop"一个值。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 与push相似，我们只需要删除LIST结尾地址的值。然后将长度减一。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 删除LIST结尾的值为常数复杂度 O(1) - "爽!!"</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="comment">// 如果没有值，则不操作。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the last value, stop storing it, and return it.</span></span><br><span class="line">    <span class="keyword">var</span> lastAddress = <span class="keyword">this</span>.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.memory[lastAddress];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.memory[lastAddress];</span><br><span class="line">    <span class="keyword">this</span>.length--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also return the value so it can be used.</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * "push" 和 "pop" 均是对LIST的结尾操作，总的来说是非常简单的，因为它们都无需考虑LIST中剩下的</span></span><br><span class="line"><span class="comment">   * 内容。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 让我们看看如果使用"unshift" 和 "shift"操作LIST的开头，会怎样？</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 想要在LIST的开头增加元素，我们需要将所有的值一个一个的向后移动，从而为新的值空出位置。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *     [a, b, c, d, e]</span></span><br><span class="line"><span class="comment">   *      0  1  2  3  4</span></span><br><span class="line"><span class="comment">   *       ⬊  ⬊  ⬊  ⬊  ⬊</span></span><br><span class="line"><span class="comment">   *         1  2  3  4  5</span></span><br><span class="line"><span class="comment">   *     [x, a, b, c, d, e]</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 为了移动LIST中所有的元素，我们需要一个个迭代每个元素。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 因为我们要迭代LIST中的每一个元素：</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 在LIST头插入一个值为线性复杂度 O(N) - "还行."</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  unshift(value) &#123;</span><br><span class="line">    <span class="comment">// 保存我们要插到首位的元素</span></span><br><span class="line">    <span class="keyword">var</span> previous = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代每一个元素...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> address = <span class="number">0</span>; address &lt; <span class="keyword">this</span>.length; address++) &#123;</span><br><span class="line">      <span class="comment">// 将"当前"值替换为"上一个"值，并为下一次迭代保存当前值。</span></span><br><span class="line">      <span class="keyword">var</span> current = <span class="keyword">this</span>.memory[address];</span><br><span class="line">      <span class="keyword">this</span>.memory[address] = previous;</span><br><span class="line">      previous = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最后的值，添加到LIST的新的最后位置。</span></span><br><span class="line">    <span class="keyword">this</span>.memory[<span class="keyword">this</span>.length] = previous;</span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最后我们需要实现shift函数，向相反方向移动。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 我们将第一个值删除，然后LIST中的其他值移动到前一个位置。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *     [x, a, b, c, d, e]</span></span><br><span class="line"><span class="comment">   *         1  2  3  4  5</span></span><br><span class="line"><span class="comment">   *       ⬋  ⬋  ⬋  ⬋  ⬋</span></span><br><span class="line"><span class="comment">   *      0  1  2  3  4</span></span><br><span class="line"><span class="comment">   *     [a, b, c, d, e]</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 删除LIST中的第一个元素为线性复杂度 O(N) - "还行."</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  shift() &#123;</span><br><span class="line">    <span class="comment">// 如果LIST为空，则什么也不做。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.memory[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代每一个元素...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> address = <span class="number">0</span>; address &lt; <span class="keyword">this</span>.length; address++) &#123;</span><br><span class="line">      <span class="comment">// 使用LIST中的下一个元素替换当前元素</span></span><br><span class="line">      <span class="keyword">this</span>.memory[address] = <span class="keyword">this</span>.memory[address + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最后一个元素，因为它已经移动到了上一个地址</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.memory[<span class="keyword">this</span>.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.length--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> LIST的优势在于快速访问，和操作最后一个元素。然而正如我们看到的，它并不擅长处理非结尾位置的<br> 元素，而且我们需要手动维护地址。</p>
<p> 所以，让我们来考一下不同的数据结构，以及它们如何处理添加，访问和无须地址删除值。</p>
<h2 id="HASH-TABLES-哈希表"><a href="#HASH-TABLES-哈希表" class="headerlink" title="HASH TABLES(哈希表)"></a>HASH TABLES(哈希表)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - HASH TABLES(哈希表) -------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                           ((\                                             *</span><br><span class="line"> *     (              _  ,-_  \ \                                            *</span><br><span class="line"> *     )             / \/  \ \ \ \                                           *</span><br><span class="line"> *     (            /)| \/\ \ \| |          .&apos;---------------------&apos;.        *</span><br><span class="line"> *     `~()_______)___)\ \ \ \ \ |        .&apos;                         &apos;.      *</span><br><span class="line"> *                 |)\ )  `&apos; | | |      .&apos;-----------------------------&apos;.    *</span><br><span class="line"> *                /  /,          |      &apos;...............................&apos;    *</span><br><span class="line"> *        ejm     |  |          /         \   _____________________   /      *</span><br><span class="line"> *                \            /           | |_)                 (_| |       *</span><br><span class="line"> *                 \          /            | |                     | |       *</span><br><span class="line"> *                  )        /             | |                     | |       *</span><br><span class="line"> **                /       /              (___)                   (___)     **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 哈希表是一个无序的数据结构。它拥有”keys” 和 “values”，我们可以根据key计算<br> 内存中的地址。</p>
<p> 基本思想是，我们操作的keys是可以”哈希化(hashable)”的 (我们很快会讲到)，并且可以非常高效地<br> 在内存中新增，访问，删除。</p>
<pre><code>var hashTable = new HashTable();

hashTable.set(&apos;myKey&apos;, &apos;myValue&apos;);
hashTable.get(&apos;myKey&apos;); // &gt;&gt; &apos;myValue&apos;
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 同样，我们使用JavaScript的普通数组来代表内存。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.memory = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为了将哈希表中的“键值对”保存到内存中，我们需要一个将key转变为地址的方法。</span></span><br><span class="line"><span class="comment">   * 我们通过“散列(hashing)”操作完成。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 基本上，它需要传入一个key的参数，然后将key序列化为一个唯一的数。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *    hashKey("abc") =&gt;  96354</span></span><br><span class="line"><span class="comment">   *    hashKey("xyz") =&gt; 119193</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 你必须注意，如果有一个很大的key，你要小心，以免它被匹配到一个并不存在的内存地址。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 所以哈希算法需要限制大小，这就意味着需要用有限的内存地址，对应无限的值。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 最终将会导致冲突，两个不同的key可能会映射到同一个内存地址。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 任何一个真正的哈希表在实现时都要处理这个问题。然而我们在这里打算忽略这个问题，假设不会</span></span><br><span class="line"><span class="comment">   * 存在这种情况。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们来建立"hashKey"函数</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 不要纠结于理解这个函数的逻辑，你只要知道它接收一个string参数，并输出我们在其他函数中需要用到的</span></span><br><span class="line"><span class="comment">   * （大多情况下）唯一的内存地址。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  hashKey(key) &#123;</span><br><span class="line">    <span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; key.length; index++) &#123;</span><br><span class="line">      <span class="comment">// Oh look– magic.</span></span><br><span class="line">      <span class="keyword">var</span> code = key.charCodeAt(index);</span><br><span class="line">      hash = ((hash &lt;&lt; <span class="number">5</span>) - hash) + code | <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面，我们来定义可以根据key取值的“get”函数。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 哈希表取值为常数复杂度 O(1) - "爽!!"</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="comment">// 我们首先将key转化为内存地址。</span></span><br><span class="line">    <span class="keyword">var</span> address = <span class="keyword">this</span>.hashKey(key);</span><br><span class="line">    <span class="comment">// 之后只要返回该地址得值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.memory[address];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们在取值之前需要保存数据，所以我们需要定义可以插入值的“set”函数</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 哈希表插入值为常数复杂度 O(1) - "爽!!"</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="comment">// 同样我们需要先将key转化为内存地址。</span></span><br><span class="line">    <span class="keyword">var</span> address = <span class="keyword">this</span>.hashKey(key);</span><br><span class="line">    <span class="comment">// 之后只要改变该地址的值。</span></span><br><span class="line">    <span class="keyword">this</span>.memory[address] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最后我们只需要一个将元素从哈希表删除的方法。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 哈希表删除为常数复杂度 O(1) - "爽!!"</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  remove(key) &#123;</span><br><span class="line">    <span class="comment">// 同样我们需要先将key转化为内存地址。</span></span><br><span class="line">    <span class="keyword">var</span> address = <span class="keyword">this</span>.hashKey(key);</span><br><span class="line">    <span class="comment">// 之后，如果这个值存在则将其`delete`。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.memory[address]) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.memory[address];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ============================================================================</span><br><span class="line"> * ,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;</span><br><span class="line"> * ============================================================================</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p> 从此往后，我们将不再与内存直接接触，因为剩下的数据结构开始基于其他数据结构而实现。</p>
<p> 这些数据结构致力于两件事情：</p>
<ul>
<li>根据使用方式组织数据。</li>
<li><p>抽象掉实现详情。</p>
<p>这些数据结构致力于建立一个结构用于各式各样的程序。它们增加了一些特定的语法，可以让你讨论更加<br>复杂的逻辑。它们都将具体的实现逻辑抽象，所以它们可以改变实现逻辑从而变得更快。</p>
</li>
</ul>
<h2 id="STACKS-栈"><a href="#STACKS-栈" class="headerlink" title="STACKS(栈)"></a>STACKS(栈)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - STACKS(栈) ---------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                             _ . - - -- .. _                               *</span><br><span class="line"> *         ||||            .-&apos;      /```\     `&apos;-_             /|            *</span><br><span class="line"> *         ||||           (     /`` \___/ ```\    )           | |            *</span><br><span class="line"> *         \__/           |`&quot;-//..__     __..\\-&quot;`|           | |            *</span><br><span class="line"> *          ||            |`&quot;||...__`````__...||&quot;`|           | |            *</span><br><span class="line"> *          ||            |`&quot;||...__`````__...||&quot;`|           \ |            *</span><br><span class="line"> *          ||       _,.--|`&quot;||...__`````__...||&quot;`|--.,_       ||            *</span><br><span class="line"> *          ||    .&apos;`     |`&quot;||...__`````__...||&quot;`|     `&apos;.    ||            *</span><br><span class="line"> *          ||   &apos;.        `/ |...__`````__...| \         .&apos;   ||            *</span><br><span class="line"> *          ||     `&apos;-..__  ``      `````      ``  __..-&apos;`     ||            *</span><br><span class="line"> *                        `&quot;&quot;---,,,_______,,,---&quot;&quot;`                          *</span><br><span class="line"> **                                                                         **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 栈与LIST有些像，因为它们都是有序的，但是栈限制你只能在结尾处“push”或“pop”值，正是我们<br> 曾看到的直接映射内存时非常快的操作。</p>
<p> 然而，为了给栈增加功能，栈也可以使用其他数据结构实现。</p>
<p> 栈最常见的用途是，一个进程向栈中增加元素，另个进程删除最近添加的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们又一次使用JavaScript数组，但是这一次它代表一个类似于我们之前实现的LIST而非内存。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = [];</span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们需要使用LIST的"push"和"pop"方法实现两个函数。</span></span><br><span class="line"><span class="comment">   * 在功能方面是相同的。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * push将元素增加到栈顶</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  push(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">    <span class="keyword">this</span>.list.push(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * pop删除栈顶的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="comment">// 如果没有内容则什么也不做</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除栈顶元素并将其返回</span></span><br><span class="line">    <span class="keyword">this</span>.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们还需要增加一个方法，可以取得栈顶的元素，但不删除它。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="comment">// 返回栈顶元素，但不删除。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[<span class="keyword">this</span>.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QUEUES-队列"><a href="#QUEUES-队列" class="headerlink" title="QUEUES(队列)"></a>QUEUES(队列)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - QUEUES(队列) --------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                   /:&quot;&quot;|                     ,@@@@@@.                      *</span><br><span class="line"> *                  |: oo|_                   ,@@@@@`oo                      *</span><br><span class="line"> *                  C     _)                  @@@@C   _)                     *</span><br><span class="line"> *                    ) /                     &quot;@@@@ &apos;=                       *</span><br><span class="line"> *                   /`\\                      ```)/                         *</span><br><span class="line"> *                  || | |                       /`\\                        *</span><br><span class="line"> *                  || | |                      || | \                       *</span><br><span class="line"> *                  ||_| |                      || | /                       *</span><br><span class="line"> *                  \( ) |                      ||_| |                       *</span><br><span class="line"> *               |~~~`-`~~~|                    |))) |                       *</span><br><span class="line"> *         (_)   |         |         (_)        |~~~/          (_)           *</span><br><span class="line"> *         | |`&quot;&quot;....__     __....&quot;&quot;`| |`&quot;&quot;...._|| /  __....&quot;&quot;`| |           *</span><br><span class="line"> *         | |`&quot;&quot;....__`````__....&quot;&quot;`| |`&quot;&quot;....__`````__....&quot;&quot;`| |           *</span><br><span class="line"> *         | |       | ||```         | |        ||`|``         | |           *</span><br><span class="line"> *         | |       |_||__          | |        ||_|__         | |           *</span><br><span class="line"> *        ,| |, jgs  (____))        ,| |,       ((;:;:)       ,| |,          *</span><br><span class="line"> **       `---`                     `---`                     `---`         **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 接下来，我们准备实现队列，它与栈类似，区别是它从队列头部删除元素而非头部。<br> 删除最早的元素而非最新的元素。</p>
<p> 同样，因为有限的功能，队列同样有很多不同的实现方式。使用链表实现或许是一个好方法，之后<br> 会为大家介绍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 同样，队列使用JavaScript的数组代表LIST而非内存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = [];</span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 与栈相似，我们需要定义两个方法用来增加和删除队列中的元素。</span></span><br><span class="line"><span class="comment">   * 首先是"enqueue"。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 它将向队列尾部增加元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  enqueue(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">    <span class="keyword">this</span>.list.push(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接下来是"dequeue"，这次我们从头部删除元素，而非从尾部。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="comment">// 如果没有内容则什么也不做</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shift取出第一个元素并将其返回</span></span><br><span class="line">    <span class="keyword">this</span>.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 与栈相似，我们需要一个"peek"函数来取得下一个元素，但不删除它</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 需要强调的是，由于我们的队列是基于LIST实现的。所以也继承了”shift”的性能，<br> 线性复杂度 O(N) “还行.”</p>
<p> 之后会为大家介绍链表(linked list)，它可以让我们实现一个更快的队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ============================================================================</span><br><span class="line"> * ,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;</span><br><span class="line"> * ============================================================================</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p> 从此往后，我们将开始操作数据结构，一个数据结构的值引用另一个数据结构。</p>
<pre><code>+- Data Structure ---------------------------------------+
|  +- Item A ---------------+ +- Item B ---------------+ |
|  | Value: 1               | | Value: 2               | |
|  | Reference to: (Item B) | | Reference to: (Item A) | |
|  +------------------------+ +------------------------+ |
+--------------------------------------------------------+
</code></pre><p> 数据结构的值将会是属于它自己的更小的数据结构，其中包含了一些附加的信息，包括指向大数据结构中<br> 其他元素的引用。</p>
<p> 你将很快明白我在说什么。</p>
<h2 id="GRAPHS-图"><a href="#GRAPHS-图" class="headerlink" title="GRAPHS(图)"></a>GRAPHS(图)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - GRAPHS(图) -------------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                                                                           *</span><br><span class="line"> *   |                                 RICK ASTLEY&apos;S NEVER GONNA...          *</span><br><span class="line"> *   |       +-+                                                             *</span><br><span class="line"> *   |  +-+  |-|                          [^] - GIVE YOU UP                  *</span><br><span class="line"> *   |  |^|  |-|                 +-+      [-] - LET YOU DOWN                 *</span><br><span class="line"> *   |  |^|  |-|       +-+       |*|      [/] - RUN AROUND AND DESERT YOU    *</span><br><span class="line"> *   |  |^|  |-|  +-+  |\|       |*|      [\] - MAKE YOU CRY                 *</span><br><span class="line"> *   |  |^|  |-|  |/|  |\|  +-+  |*|      [.] - SAY GOODBYE                  *</span><br><span class="line"> *   |  |^|  |-|  |/|  |\|  |.|  |*|      [*] - TELL A LIE AND HURT YOU      *</span><br><span class="line"> *   |  |^|  |-|  |/|  |\|  |.|  |*|                                         *</span><br><span class="line"> *   +--------------------------------                                       *</span><br><span class="line"> **                                                                         **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 与上面的字符图不同，图并不是某种类型的可视化图表。</p>
<p> 而是把它想象成这个样子：</p>
<pre><code>A –→ B ←–––– C → D ↔ E
↑    ↕     ↙ ↑     ↘
F –→ G → H ← I ––––→ J
     ↓     ↘ ↑
     K       L
</code></pre><p> 我们有一堆用线彼此相连的“节点(node)” (A, B, C, D, …)。</p>
<p> 这些节点看上去是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node &#123;</span><br><span class="line">  value: ...,</span><br><span class="line">  lines: [(Node), (Node), ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 整个图，看上去是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Graph &#123;</span><br><span class="line">  nodes: [</span><br><span class="line">    Node &#123;...&#125;,</span><br><span class="line">    Node &#123;...&#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们准备将所有的节点放到JavaScript普通数组里。并非因为各个节点之间存在顺序，而是因为</span></span><br><span class="line"><span class="comment">   * 我们需要一种保存所有引用的方式。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们可以向创建的nodes里添加值，无需添加任何联系(lines)。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  addNode(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.nodes.push(&#123;</span><br><span class="line">      value: value,</span><br><span class="line">      lines: []</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面，我们需要在图里查找nodes。大多情况下为了让搜索更快，在图之上会创建另一个</span></span><br><span class="line"><span class="comment">   * 数据结构。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 但是我们这里，只想简单的遍历所有的nodes，来查找我们需要的值。这是一个低效的选择，</span></span><br><span class="line"><span class="comment">   * 但在此还是够用的。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  find(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nodes.find(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> node.value === value;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面我们可以在两个节点通过一条"线(line)"连接起来。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  addLine(startValue, endValue) &#123;</span><br><span class="line">    <span class="comment">// 找到各个值所对应的节点</span></span><br><span class="line">    <span class="keyword">var</span> startNode = <span class="keyword">this</span>.find(startValue);</span><br><span class="line">    <span class="keyword">var</span> endNode = <span class="keyword">this</span>.find(endValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点不存在时抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!startNode || !endNode) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Both nodes need to exist'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为startNode添加endNode的索引。</span></span><br><span class="line">    startNode.lines.push(endNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 最后你可以这样使用图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var graph = new Graph();</span><br><span class="line">graph.addNode(1);</span><br><span class="line">graph.addNode(2);</span><br><span class="line">graph.addLine(1, 2);</span><br><span class="line">var two = graph.find(1).lines[0];</span><br></pre></td></tr></table></figure>
<p> 这看起来或许费了很多功夫做了很少的事情，但是它其实是一个很强大的模式，尤其是在复杂<br> 程序中查找想要的东西时。</p>
<p> 它们通过优化数据间的联系实现，而非操作数据本身。如果你知道图中有某个节点，那就很容易找到<br> 图中与它有关系的所有元素了。</p>
<p> 太多东西都可以用这种方式抽象，好友圈，node_modules文件夹中的传递依赖，因特网本身也是<br> 通过链接将网页连接到一起的图。</p>
<h2 id="LINKED-LISTS-链表"><a href="#LINKED-LISTS-链表" class="headerlink" title="LINKED LISTS(链表)"></a>LINKED LISTS(链表)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - LINKED LISTS(链表) --------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *      _______________________                                              *</span><br><span class="line"> *  ()=(_______________________)=()              ,-----------------,_        *</span><br><span class="line"> *      |                     |               ,&quot;                      &quot;,     *</span><br><span class="line"> *      |   ~ ~~~~~~~~~~~~~   |             ,&apos;    ,---------------,     `,   *</span><br><span class="line"> *      |               ,----------------------------,          ,----------- *</span><br><span class="line"> *      |   ~ ~~~~~~~~ |                              |        |             *</span><br><span class="line"> *      |               `----------------------------&apos;          `----------- *</span><br><span class="line"> *      |   ~ ~~~~~~~~~~~~~   |            `,    `----------------&apos;     ,&apos;   *</span><br><span class="line"> *      |                     |              `,                      ,&apos;      *</span><br><span class="line"> *      |_____________________|                 `------------------&apos;         *</span><br><span class="line"> *  ()=(_______________________)=()                                          *</span><br><span class="line"> **                                                                         **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 下面，将为大家介绍类-图结构怎样帮助优化数据列表的。</p>
<p> Linked lists(链表)是非常常见的数据结构，由于它向开头，中间及结尾插入元素都非常的高效，<br> 所以它常常被用与实现其他的数据结构。</p>
<p> 链表的基础理念和图非常像。一个节点指向另一个节点，它看上去大概是这样的：</p>
<pre><code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5
</code></pre><p> 将其可视化为类JSON结构，看上去像这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  next: &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    next: &#123;</span><br><span class="line">      value: 3,</span><br><span class="line">      next: &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 与图不同，整个链表只有一个节点作为链的开头。被称为链表的"head(头部)"。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 我们同样打算记录链表的长度。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 首先我们需要一个方法取得所给位置的值。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 这与常见的list不太一样，我们不能直接跳到对应的位置。而是需要在每个节点上移动。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  get(position) &#123;</span><br><span class="line">    <span class="comment">// 如果该位置比元素总数还大，则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="keyword">this</span>.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Position outside of list range'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头结点开始</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用node.next通过每一个元素，直到到达给定的位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; position; index++) &#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回我们找到的节点。</span></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面我们需要向特定的位置增加节点。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 我们准备建立一个通用的add方法，接收value和position参数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  add(value, position) &#123;</span><br><span class="line">    <span class="comment">// 首先创建一个node承载value。</span></span><br><span class="line">    <span class="keyword">var</span> node = &#123;</span><br><span class="line">      value: value,</span><br><span class="line">      next: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点插入到头部是一个特殊情况。</span></span><br><span class="line">    <span class="comment">// 我们将要插入节点的"next"参数指向当前的头部，再用其替代头部。</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      node.next = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="keyword">this</span>.head = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们要在其他位置插入节点，我们需要将它与此位置当前的节点，和上一个节点连接到一起。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 首先找到当前位置的节点，与上一个节点。</span></span><br><span class="line">      <span class="keyword">var</span> prev = <span class="keyword">this</span>.get(position - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">var</span> current = prev.next;</span><br><span class="line">      <span class="comment">// 之后将要插入节点的"next"参数指向当前位置的节点，再将上一个节点的"next"参数改为 </span></span><br><span class="line">      <span class="comment">// 要插入的新节点。</span></span><br><span class="line">      node.next = current;</span><br><span class="line">      prev.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后增加length。</span></span><br><span class="line">    <span class="keyword">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最后我们需要一个删除方法。我们只需找到相应的节点，然后将其从链中剔除。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  remove(position) &#123;</span><br><span class="line">    <span class="comment">// 如果要删除第一个节点的话，只需要将head指向第二个节点。</span></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于其他位置，我们需要找到它的上一个节点，然后将上一个节点</span></span><br><span class="line">    <span class="comment">// 的"next"参数设为当前位置节点的下一个节点。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> prev = <span class="keyword">this</span>.get(position - <span class="number">1</span>);</span><br><span class="line">      prev.next = prev.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后减小length</span></span><br><span class="line">    <span class="keyword">this</span>.length--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ============================================================================</span><br><span class="line"> * ,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;`&apos;-.,.-&apos;</span><br><span class="line"> * ============================================================================</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p> 我们准备了解的剩下的两个数据结构都属于”tree(树)”家族。</p>
<p> 和现实中一样，有很多不同种类的树的数据结构。(译者：恕我无能)</p>
<pre><code>Binary Trees:
  AA Tree, AVL Tree, Binary Search Tree, Binary Tree, Cartesian Tree,
  left child/right sibling tree, order statistic tree, Pagoda, ...

B Trees:
  B Tree, B+ Tree, B* Tree, B Sharp Tree, Dancing Tree, 2-3 Tree, ...

Heaps:
  Heap, Binary Heap, Weak Heap, Binomial Heap, Fibonacci Heap, Leonardo
  Heap, 2-3 Heap, Soft Heap, Pairing Heap, Leftist Heap, Treap, ...

Trees:
  Trie, Radix Tree, Suffix Tree, Suffix Array, FM-index, B-trie, ...

Multi-way Trees:
  Ternary Tree, K-ary tree, And-or tree, (a,b)-tree, Link/Cut Tree, ...

Space Partitioning Trees:
  Segment Tree, Interval Tree, Range Tree, Bin, Kd Tree, Quadtree,
  Octree, Z-Order, UB-Tree, R-Tree, X-Tree, Metric Tree, Cover Tree, ...

Application-Specific Trees:
  Abstract Syntax Tree, Parse Tree, Decision Tree, Minimax Tree, ...
</code></pre><p> 你肯定没想到，今天你会在这里学习树木学……而且那还不是所有的树。但是不要害怕，它们中的大多数<br> 并不重要。它们只是很多计算机科学博士需要证明一些东西的时候用到的。</p>
<p> 树对于图还有链表在除了它是“单向的”方面，其他方面都很像。也就是说，它不会有引用循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    树:                     非树:</span><br><span class="line"></span><br><span class="line">    A                        A</span><br><span class="line">  ↙   ↘                    ↗   ↘</span><br><span class="line">B       C                B ←–––– C</span><br></pre></td></tr></table></figure>
<p> 如果你在树的节点之间建立了循环的联系，那么它就不再是树了。</p>
<p> 树有很多用处，它可以用于优化搜索和排序。它可以让你更好的组织程序。它可以为你提供更易工作的<br> 形式。</p>
<h2 id="TREES-树"><a href="#TREES-树" class="headerlink" title="TREES(树)"></a>TREES(树)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - TREES(树) ----------------------------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *            ccee88oo             \ | /                                     *</span><br><span class="line"> *          C8O8O8Q8PoOb o8oo    &apos;-.;;;.-,   ooooO8O8QOb o8bDbo              *</span><br><span class="line"> *        dOB69QO8PdUOpugoO9bD  -==;;;;;==-aadOB69QO8PdUOpugoO9bD            *</span><br><span class="line"> *       CgggbU8OU qOp qOdoUOdcb .-&apos;;;;&apos;-.  CgggOU ddqOp qOdoUOdcb           *</span><br><span class="line"> *           6OuU  /p u gcoUodpP   / | \ jgs  ooSec cdac pdadfoof            *</span><br><span class="line"> *             \\\//  /douUP         &apos;         \\\d\\\dp/pddoo               *</span><br><span class="line"> *               \\\////                         \\ \\////                   *</span><br><span class="line"> *                |||/\                           \\///                      *</span><br><span class="line"> *                |||\/                           ||||                       *</span><br><span class="line"> *                |||||                          /|||                        *</span><br><span class="line"> ** .............//||||\.......................//|||\\..................... **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 我们从一个非常简单的树结构起步。它没有任何特殊的规则，看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tree &#123;</span><br><span class="line">  root: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      value: 2,</span><br><span class="line">      children: [...]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      value: 3,</span><br><span class="line">      children: [...]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 树由一个parent开始，他被称为树的"root"。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我们需要一种方法来遍历整个数，对于每个node都会调用传入的callback函数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  traverse(callback) &#123;</span><br><span class="line">    <span class="comment">// 我们定义一个walk函数，它可以递归地遍历树的每一个节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 首先为此节点调用callback</span></span><br><span class="line">      callback(node);</span><br><span class="line">      <span class="comment">// 然后为他的子节点递归调用walk。</span></span><br><span class="line">      node.children.forEach(walk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now kick the traversal process off.</span></span><br><span class="line">    walk(<span class="keyword">this</span>.root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面我们需要向树添加节点的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  add(value, parentValue) &#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = &#123;</span><br><span class="line">      value: value,</span><br><span class="line">      children: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有root，则将其设为root。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.root = newNode;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则遍历整个树，查找匹配的节点，然后将新节点设为它的子节点。</span></span><br><span class="line">    <span class="keyword">this</span>.traverse(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (node.value === parentValue) &#123;</span><br><span class="line">        node.children.push(newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这是一个最基础的树，它可能只有在你想代表的数据酷似树的时候才有用。</p>
<p> 但是，添加一些额外的规则，树可以为很多不同的需求服务。</p>
<h2 id="BINARY-SEARCH-TREES-二叉搜索树"><a href="#BINARY-SEARCH-TREES-二叉搜索树" class="headerlink" title="BINARY SEARCH TREES(二叉搜索树)"></a>BINARY SEARCH TREES(二叉搜索树)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - BINARY SEARCH TREES(二叉搜索树) --------------------------------------- **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> * 0 0 1 0 1 0 0 1 0 1 1 1 0 1  ,@@@@@@@@@@@@@@,   0 0 1 0 1 0 0 1 0 1 1 1 0 *</span><br><span class="line"> * 0 1 0 1 0 1 0 1 1 0 1 1 0  @@`              &apos;@@   0 1 0 1 0 1 1 0 1 0 1 0 *</span><br><span class="line"> * 1 1 0 0 0 1 0 0 1 1 1 0  @@`   8O8PoOb o8o    &apos;@@   0 0 1 0 0 1 0 0 1 1 1 *</span><br><span class="line"> * 0 0 1 1 0 1 0 1 0 0 0  @@   dOB69QO8PdUgoO9bD    @@   1 0 1 1 0 1 0 1 0 0 *</span><br><span class="line"> * ===================== @@   CgbU8OU qOp qOdOdcb    @@  0 1 1 0 1 0 1 0 1 0 *</span><br><span class="line"> *                       @@      6OU /p u gcoUpP     @@  1 0 1 1 0 1 0 0 1 1 *</span><br><span class="line"> * ===================== @@         \\// /doP        @@  0 1 1 0 0 1 0 0 1 0 *</span><br><span class="line"> * 1 1 0 0 1 1 0 1 1 0 0  @@         \\//           @@   1 0 1 0 0 1 1 0 1 1 *</span><br><span class="line"> * 0 1 1 0 1 0 1 1 0 1 1 0  @@,      |||          ,@@  0 1 1 0 1 1 0 0 1 0 1 *</span><br><span class="line"> * 1 0 1 0 1 1 0 0 1 0 0 1 0  @@,   //|\       ,@@   0 1 0 1 0 1 1 0 0 1 1 0 *</span><br><span class="line"> **  1 0 1 0 0 1 1 0 1 0 1 0 1  `@@@@@@@@@@@@@@&apos;   0 1 1 1 0 0 1 0 1 0 1 1  **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 二叉搜索树是树的一个非常普遍的方式，因为它可以高效的访问，搜索，插入以及删除值，同时<br> 保持它们有序。</p>
<p> 假如有这么一串数字：</p>
<pre><code>1  2  3  4  5  6  7
</code></pre><p> 让后将其转换为从中间开始的树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          4</span><br><span class="line">       /     \</span><br><span class="line">    2           6</span><br><span class="line">  /   \       /   \</span><br><span class="line"> 1     3     5     7</span><br><span class="line">-^--^--^--^--^--^--^-</span><br><span class="line"> 1  2  3  4  5  6  7</span><br></pre></td></tr></table></figure>
<p> 二叉树是这样工作的。每个节点有两个子节点：</p>
<ul>
<li>左节点: 比父节点的值小。</li>
<li><p>右节点: 比父节点的值大。</p>
<blockquote>
<p>提示: 树中的值必须唯一。</p>
</blockquote>
<p>这使得遍历查值使非常的有效率。比如我们想要找到树种的5：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        (4)         &lt;--- 5 &gt; 4, 向右.</span><br><span class="line">      /     \</span><br><span class="line">   2         (6)    &lt;--- 5 &lt; 6, 向左.</span><br><span class="line"> /   \       /   \</span><br><span class="line">1     3    (5)    7 &lt;--- 找到 5!</span><br></pre></td></tr></table></figure>
<p> 需要强调的是，我们只需要3此判断就找到了5。如果我们将这个树扩充到1000个元素。<br> 我们需要:</p>
<p>   500 -&gt; 250 -&gt; 125 -&gt; 62 -&gt; 31 -&gt; 15 -&gt; 7 -&gt; 3 -&gt; 4 -&gt; 5</p>
<p> 1000个元素仅需10次判断！</p>
<p> 另一个，二叉搜索树在删除或新增值时和链表很像，你只需更新它周围的元素就可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 和之前的树一样，二叉搜索树也有"root".</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 想要知道，某个值是否在树里，我们需要在树中搜索。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  contains(value) &#123;</span><br><span class="line">    <span class="comment">// 从root开始</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要有下一个节点，我们就要继续搜索。</span></span><br><span class="line">    <span class="comment">// 如果`left` 或 `right` 的值为 `null` 便结束搜索。</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果比current.value大，则移向右节点</span></span><br><span class="line">      <span class="keyword">if</span> (value &gt; current.value) &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果比current.value小，则移向左节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; current.value) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 否则肯定是相等，那么返回true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有匹配项，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 像树种添加元素，同样需要向之前那样遍历树，向左或向右取决于此节点大于或小于我们准备</span></span><br><span class="line"><span class="comment">   * 增加的值。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 不同的是，如果最终 `left` 或 `right` 是 `null` 时，我们将新的节点放在此位置。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  add(value) &#123;</span><br><span class="line">    <span class="comment">// 首先初始化节点。</span></span><br><span class="line">    <span class="keyword">var</span> node = &#123;</span><br><span class="line">      value: value,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于没有root的特殊情况，我们只需要将其设为root。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.root = node;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由root开始。</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续循环，直到新节点添加完成，或发现该值已存在。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果比current.value大，则移向右节点</span></span><br><span class="line">      <span class="keyword">if</span> (value &gt; current.value) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 `right` 不存在，将其设为我们的节点并停止遍历。</span></span><br><span class="line">        <span class="keyword">if</span> (!current.right) &#123;</span><br><span class="line">          current.right = node;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则移向右节点</span></span><br><span class="line">        current = current.right;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果比current.value小，则移向左节点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; current.value) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 `left` 不存在，将其设为我们的节点并停止遍历。</span></span><br><span class="line">        <span class="keyword">if</span> (!current.left) &#123;</span><br><span class="line">          current.left = node;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则移向左节点</span></span><br><span class="line">        current = current.left;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果要插入的值已存在则终止</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="YOU-REACHED-THE-END"><a href="#YOU-REACHED-THE-END" class="headerlink" title="YOU REACHED THE END!"></a>YOU REACHED THE END!</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*** ===================================================================== ***\</span><br><span class="line"> ** - YOU REACHED THE END! ------------------------------------------------ **</span><br><span class="line"> * ========================================================================= *</span><br><span class="line"> *                                           .&apos;&apos;.                            *</span><br><span class="line"> *                 .&apos;&apos;.             *&apos;&apos;*    :_\/_:     .                     *</span><br><span class="line"> *                :_\/_:   .    .:.*_\/_*   : /\ :  .&apos;.:.&apos;.                  *</span><br><span class="line"> *            .&apos;&apos;.: /\ : _\(/_  &apos;:&apos;* /\ *  : &apos;..&apos;.  -=:o:=-                  *</span><br><span class="line"> *           :_\/_:&apos;.:::. /)\*&apos;&apos;*  .|.* &apos;.\&apos;/.&apos;_\(/_&apos;.&apos;:&apos;.&apos;                  *</span><br><span class="line"> *           : /\ : :::::  &apos;*_\/_* | |  -= o =- /)\    &apos;  *                  *</span><br><span class="line"> *            &apos;..&apos;  &apos;:::&apos;   * /\ * |&apos;|  .&apos;/.\&apos;.  &apos;._____                     *</span><br><span class="line"> *                *        __*..* |  |     :      |.   |&apos; .---&quot;|             *</span><br><span class="line"> *                 _*   .-&apos;   &apos;-. |  |     .--&apos;|  ||   | _|    |             *</span><br><span class="line"> *              .-&apos;|  _.|  |    ||   &apos;-__  |   |  |    ||      |             *</span><br><span class="line"> *              |&apos; | |.    |    ||       | |   |  |    ||      |             *</span><br><span class="line"> * _____________|  &apos;-&apos;     &apos;    &quot;&quot;       &apos;-&apos;   &apos;-.&apos;    &apos;`      |____________ *</span><br><span class="line"> ** jgs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **</span><br><span class="line">\*** ===================================================================== ***/</span><br></pre></td></tr></table></figure>
<p> 可能内容有些多，但我希望它对你有帮助。如果你喜欢这些内容，欢迎star项目<br> 或者粉我的twitter (@thejameskyle)?</p>
<p> 你也可以看一下我的另一篇文章 “The Super Tiny Compiler”<br>       here ——&gt; <a href="https://github.com/thejameskyle/the-super-tiny-compiler" target="_blank" rel="noopener">https://github.com/thejameskyle/the-super-tiny-compiler</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-09-08</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://blog.sjfkai.com/2016/09/08/简易数据结构/,Just Blog,简易数据结构,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/11/04/通过travis自动部署hexo博客到github-pages/" title="通过travis自动部署hexo博客到github pages" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/05/29/将地址批量转换为经纬度/" title="将地址批量转换为经纬度" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="gitalk_thread"></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script>(function() {
    var gitalk = new Gitalk({
        clientID: '42fc6cc03e9748504521',
        clientSecret: '276e368ccf374058acd40e6e5c9dc9589e08460d',
        repo: 'blog',
        owner: 'sjfkai',
        admin: 'sjfkai',
        id: md5(location.pathname),      // Ensure uniqueness and length less than 50
        distractionFreeMode: 'true'  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk_thread')
})();</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>